<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>瑜伽動作應用 - Assignment 2.2</title>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@ionic/core/dist/ionic/ionic.esm.js"
    ></script>
    <script
      nomodule
      src="https://cdn.jsdelivr.net/npm/@ionic/core/dist/ionic/ionic.js"
    ></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@ionic/core/css/ionic.bundle.css"
    />
    
    <style>
      /* 與原版相同的樣式 */
      .item-image {
        width: 100%;
        max-width: 300px;
        height: auto;
        border-radius: 8px;
        margin-bottom: 10px;
      }
      
      .video-thumbnail {
        position: relative;
        display: inline-block;
        cursor: pointer;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        transition: transform 0.2s ease;
      }
      
      .video-thumbnail:hover {
        transform: scale(1.02);
      }
      
      .poses-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        padding: 16px;
      }
      
      .pose-card {
        flex: 1 1 300px;
        min-width: 280px;
      }
      
      .filter-container {
        padding: 16px;
        background: #f8f9fa;
        border-bottom: 1px solid #e0e0e0;
      }
      
      .filter-row {
        display: flex;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
      }
      
      .filter-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .filter-item label {
        font-size: 14px;
        font-weight: 500;
        color: #666;
      }
      
      @media (max-width: 768px) {
        .filter-row {
          flex-direction: column;
          align-items: stretch;
        }
        
        .filter-item {
          width: 100%;
        }
      }
      
      /* 認證表單樣式 */
      .form-group {
        margin-bottom: 20px;
      }
      
      /* 自定義輸入框樣式 - 修復重疊問題 */
      .custom-input-item {
        --padding-start: 16px;
        --inner-padding-end: 16px;
        --min-height: 60px;
        --background: transparent;
        --border-radius: 8px;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        margin-bottom: 8px;
      }
      
      .custom-input-item:focus-within {
        border-color: var(--ion-color-primary);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      
      .custom-input-item ion-label {
        font-size: 12px;
        font-weight: 500;
        color: #6b7280;
        margin-bottom: 4px;
        position: static !important;
        transform: none !important;
      }
      
      .custom-input-item ion-input {
        --padding-top: 8px;
        --padding-bottom: 8px;
        --padding-start: 0px;
        font-size: 16px;
        line-height: 1.5;
      }
      
      .custom-input-item ion-input input {
        padding-left: 0 !important;
      }
      
      /* 佔位符樣式 */
      .custom-input-item ion-input::part(native) {
        color: #374151;
      }
      
      .custom-input-item ion-input::part(native)::placeholder {
        color: #9ca3af;
        opacity: 1;
      }
      
      /* 當輸入框獲得焦點時隱藏佔位符 */
      .custom-input-item:focus-within ion-input::part(native)::placeholder {
        opacity: 0.3;
      }
      
      .error-message {
        color: #dc3545;
        font-size: 12px;
        margin-top: 5px;
        margin-left: 16px;
        display: none;
      }
      
      .error-message.show {
        display: block;
      }
      
      .password-requirements {
        margin-top: 5px;
        margin-left: 16px;
        color: #6c757d;
      }
      
      .form-actions {
        margin: 24px 0;
      }
      
      .form-switch {
        text-align: center;
        margin-top: 16px;
      }
      
      .auth-error {
        margin: 16px 0;
        padding: 12px;
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 8px;
        color: #721c24;
      }
      
      .auth-error.show {
        display: block !important;
      }
      
      .loading-spinner {
        width: 16px;
        height: 16px;
        margin-right: 8px;
      }
      
      .password-strength {
        margin-top: 5px;
        margin-left: 16px;
      }
      
      .password-strength-bar {
        height: 4px;
        background: #e9ecef;
        border-radius: 2px;
        margin-top: 4px;
        overflow: hidden;
      }
      
      .password-strength-fill {
        height: 100%;
        transition: width 0.3s ease, background-color 0.3s ease;
      }
      
      .strength-weak { background-color: #dc3545; }
      .strength-medium { background-color: #ffc107; }
      .strength-strong { background-color: #28a745; }
      
      /* 輸入框聚焦效果 */
      .form-group ion-item {
        --border-radius: 8px;
        --background: #f8f9fa;
        margin-bottom: 8px;
        transition: all 0.3s ease;
      }
      
      .form-group ion-item.item-has-focus {
        --background: #ffffff;
        --border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
      }
      
      .form-group ion-input {
        --placeholder-color: #6c757d;
        --color: #212529;
      }
      
      /* 浮動標籤動畫 */
      .form-group ion-label {
        transition: all 0.3s ease;
      }
    </style>
  </head>
  <body>
    <ion-app>
      <!-- Header -->
      <ion-header>
        <ion-toolbar>
          <ion-title>瑜伽動作應用</ion-title>
          <ion-buttons slot="end">
            <ion-button id="auth-btn">登入</ion-button>
          </ion-buttons>
        </ion-toolbar>
      </ion-header>

      <!-- Content -->
      <ion-content>
        <!-- 搜索和篩選區域 -->
        <div class="filter-container">
          <div class="filter-row">
            <div class="filter-item" style="flex: 2;">
              <label>搜索瑜伽動作</label>
              <ion-searchbar id="search-bar" placeholder="搜索動作名稱、描述或好處..."></ion-searchbar>
            </div>
            
            <div class="filter-item">
              <label>分類篩選</label>
              <ion-select id="category-select" placeholder="所有分類">
                <ion-select-option value="">所有分類</ion-select-option>
                <ion-select-option value="站姿式">站姿式</ion-select-option>
                <ion-select-option value="坐姿式">坐姿式</ion-select-option>
                <ion-select-option value="平衡式">平衡式</ion-select-option>
                <ion-select-option value="後彎式">後彎式</ion-select-option>
                <ion-select-option value="前彎式">前彎式</ion-select-option>
                <ion-select-option value="扭轉式">扭轉式</ion-select-option>
                <ion-select-option value="倒立式">倒立式</ion-select-option>
                <ion-select-option value="休息式">休息式</ion-select-option>
                <ion-select-option value="開髖式">開髖式</ion-select-option>
              </ion-select>
            </div>
            
            <!-- Step 22: 排序功能 -->
            <div class="filter-item">
              <label>排序方式</label>
              <ion-select id="sort-select" placeholder="預設排序">
                <ion-select-option value="">預設排序</ion-select-option>
                <ion-select-option value="name">按名稱排序</ion-select-option>
                <ion-select-option value="difficulty">按難度排序</ion-select-option>
                <ion-select-option value="duration_minutes">按時長排序</ion-select-option>
                <ion-select-option value="category">按分類排序</ion-select-option>
              </ion-select>
            </div>
            
            <div class="filter-item">
              <label>排序順序</label>
              <ion-select id="order-select" value="asc">
                <ion-select-option value="asc">升序 (A-Z, 1-9)</ion-select-option>
                <ion-select-option value="desc">降序 (Z-A, 9-1)</ion-select-option>
              </ion-select>
            </div>
            
            <!-- Step 23: 只顯示已收藏項目過濾 -->
            <div class="filter-item">
              <label>收藏過濾</label>
              <ion-button id="bookmark-filter-btn" fill="outline" color="primary" onclick="toggleBookmarkFilter()">
                <ion-icon name="heart-outline"></ion-icon>
                顯示全部
              </ion-button>
            </div>
            
            <div class="filter-item">
              <label>每頁顯示</label>
              <ion-select id="limit-select" value="5">
                <ion-select-option value="5">5 項</ion-select-option>
                <ion-select-option value="10">10 項</ion-select-option>
                <ion-select-option value="20">20 項</ion-select-option>
                <ion-select-option value="50">50 項</ion-select-option>
              </ion-select>
            </div>
          </div>
        </div>

        <!-- 載入狀態 -->
        <div id="loading-container" style="text-align: center; padding: 40px;">
          <ion-spinner name="crescent"></ion-spinner>
          <p id="loading-message">載入瑜伽動作中...</p>
        </div>
        
        <!-- 錯誤狀態 -->
        <div id="error-container" style="display: none; text-align: center; padding: 40px;">
          <p id="error-message">載入失敗</p>
          <ion-button id="retry-btn" onclick="loadData()">重試</ion-button>
        </div>
        
        <!-- 數據顯示區域 -->
        <div id="poses-list" style="display: none;">
          <!-- 瑜伽動作卡片將在這裡顯示 -->
        </div>
        
        <!-- 分頁信息和無限滾動 -->
        <div id="pagination-container" style="display: none; text-align: center; padding: 20px;">
          <p id="pagination-info">顯示第 1-10 項，共 50 項</p>
          
          <!-- Step 24: 無限滾動載入指示器 -->
          <div id="infinite-scroll-loading" style="display: none; padding: 20px; text-align: center;">
            <ion-spinner name="crescent" style="margin-right: 10px; --color: #3880ff;"></ion-spinner>
            <span style="color: #3880ff; font-size: 14px;">向下滾動自動載入更多...</span>
          </div>
          
          <!-- 無限滾動載入錯誤提示 -->
          <div id="load-more-error" style="display: none; color: #e53e3e; margin-top: 10px; text-align: center;">
            <ion-icon name="alert-circle-outline" style="margin-right: 5px;"></ion-icon>
            <span>載入失敗，繼續向下滾動將自動重試</span>
          </div>
          
          <!-- 無更多數據指示器 -->
          <div id="no-more-data" style="display: none; color: #718096; margin-top: 15px; text-align: center; padding: 10px;">
            <ion-icon name="checkmark-circle-outline" style="margin-right: 5px;"></ion-icon>
            <span>已載入所有瑜伽動作</span>
          </div>
        </div>
      </ion-content>

      <!-- 登入/註冊模態框 -->
      <ion-modal id="auth-modal">
        <ion-header>
          <ion-toolbar>
            <ion-title id="auth-title">登入</ion-title>
            <ion-buttons slot="end">
              <ion-button onclick="closeAuthModal()">
                <ion-icon name="close"></ion-icon>
              </ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        
        <ion-content class="ion-padding">
          <!-- 認證表單容器 -->
          <div id="auth-form-container">
            <!-- 登錄表單 -->
            <form id="login-form" style="display: block;">
              <div class="form-group">
                <ion-item lines="none" class="custom-input-item">
                  <ion-label position="stacked">用戶名或郵件</ion-label>
                  <ion-input 
                    id="login-username" 
                    type="text" 
                    placeholder="請輸入用戶名或郵件"
                    required 
                    clearInput="true"
                    autocomplete="username">
                  </ion-input>
                </ion-item>
                <div id="login-username-error" class="error-message"></div>
              </div>
              
              <div class="form-group">
                <ion-item lines="none" class="custom-input-item">
                  <ion-label position="stacked">密碼</ion-label>
                  <ion-input 
                    id="login-password" 
                    type="password" 
                    placeholder="請輸入密碼"
                    required 
                    clearInput="true"
                    autocomplete="current-password">
                  </ion-input>
                </ion-item>
                <div id="login-password-error" class="error-message"></div>
              </div>
              
              <div class="form-actions">
                <ion-button 
                  id="login-submit-btn" 
                  expand="block" 
                  type="submit"
                  color="primary">
                  <ion-icon name="log-in" slot="start"></ion-icon>
                  <span id="login-btn-text">登錄</span>
                </ion-button>
              </div>
              
              <div class="form-switch">
                <ion-button 
                  id="switch-to-register" 
                  fill="clear" 
                  expand="block">
                  還沒有帳號？點擊註冊
                </ion-button>
              </div>
            </form>
            
            <!-- 註冊表單 -->
            <form id="register-form" style="display: none;">
              <div class="form-group">
                <ion-item lines="none" class="custom-input-item">
                  <ion-label position="stacked">用戶名</ion-label>
                  <ion-input 
                    id="register-username" 
                    type="text" 
                    placeholder="請輸入用戶名（3-20個字符）"
                    required 
                    clearInput="true"
                    autocomplete="username">
                  </ion-input>
                </ion-item>
                <div id="register-username-error" class="error-message"></div>
              </div>
              
              <div class="form-group">
                <ion-item lines="none" class="custom-input-item">
                  <ion-label position="stacked">電子郵件</ion-label>
                  <ion-input 
                    id="register-email" 
                    type="email" 
                    placeholder="請輸入電子郵件地址"
                    required 
                    clearInput="true"
                    autocomplete="email">
                  </ion-input>
                </ion-item>
                <div id="register-email-error" class="error-message"></div>
              </div>
              
              <div class="form-group">
                <ion-item lines="none" class="custom-input-item">
                  <ion-label position="stacked">密碼</ion-label>
                  <ion-input 
                    id="register-password" 
                    type="password" 
                    placeholder="請輸入密碼（至少8個字符）"
                    required 
                    clearInput="true"
                    autocomplete="new-password">
                  </ion-input>
                </ion-item>
                <div id="register-password-error" class="error-message"></div>
                
                <!-- Step 25: 密碼強度指示器 -->
                <div id="password-strength-container" style="margin-top: 10px; display: none;">
                  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                    <span style="font-size: 14px; font-weight: 500;">密碼強度:</span>
                    <div id="password-strength-bar" style="flex: 1; height: 6px; background: #e0e0e0; border-radius: 3px; overflow: hidden;">
                      <div id="password-strength-fill" style="height: 100%; width: 0%; transition: width 0.3s, background-color 0.3s;"></div>
                    </div>
                    <span id="password-strength-text" style="font-size: 12px; font-weight: 500;">弱</span>
                  </div>
                  <div id="password-requirements-checklist" style="font-size: 12px; color: #666;">
                    <div id="req-length">✗ 至少8個字符</div>
                    <div id="req-lowercase">✗ 包含小寫字母</div>
                    <div id="req-uppercase">✗ 包含大寫字母</div>
                    <div id="req-numbers">✗ 包含數字</div>
                    <div id="req-special">○ 包含特殊字符 (可選)</div>
                  </div>
                </div>
                
                <div class="password-requirements">
                  <small>請輸入符合安全要求的密碼</small>
                </div>
              </div>
              
              <div class="form-group">
                <ion-item lines="none" class="custom-input-item">
                  <ion-label position="stacked">確認密碼</ion-label>
                  <ion-input 
                    id="register-confirm-password" 
                    type="password" 
                    placeholder="請再次輸入密碼"
                    required 
                    clearInput="true"
                    autocomplete="new-password">
                  </ion-input>
                </ion-item>
                <div id="register-confirm-password-error" class="error-message"></div>
              </div>
              
              <div class="form-actions">
                <ion-button 
                  id="register-submit-btn" 
                  expand="block" 
                  type="submit"
                  color="success">
                  <ion-icon name="person-add" slot="start"></ion-icon>
                  <span id="register-btn-text">註冊</span>
                </ion-button>
              </div>
              
              <div class="form-switch">
                <ion-button 
                  id="switch-to-login" 
                  fill="clear" 
                  expand="block">
                  已有帳號？點擊登錄
                </ion-button>
              </div>
            </form>
            
            <!-- API 錯誤信息顯示 -->
            <div id="auth-error" class="auth-error" style="display: none;"></div>
          </div>
        </ion-content>
      </ion-modal>

      <!-- 登出確認模態框 -->
      <ion-modal id="logout-confirm-modal">
        <ion-header>
          <ion-toolbar>
            <ion-title>確認登出</ion-title>
          </ion-toolbar>
        </ion-header>
        
        <ion-content>
          <div style="padding: 20px; text-align: center;">
            <p>您確定要登出嗎？</p>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
              <ion-button fill="outline" onclick="closeLogoutModal()">取消</ion-button>
              <ion-button onclick="confirmLogout()">確認登出</ion-button>
            </div>
          </div>
        </ion-content>
      </ion-modal>
    </ion-app>

    <script>
      // 配置常數 - Step 27: 程式碼優化
      const CONFIG = {
        API_BASE_URL: 'https://dae-mobile-assignment.hkit.cc/api',
        MAX_RETRIES: 15,
        SESSION_TIMEOUT: 24 * 60 * 60 * 1000, // 24小時
        SEARCH_DELAY: 500, // 搜索延遲毫秒
        INFINITE_SCROLL_THRESHOLD: 100, // 距離底部觸發載入的像素 (降低閾值)
        ITEMS_PER_PAGE_OPTIONS: [5, 10, 20, 50],
        ERROR_DISPLAY_TIMEOUT: 5000, // 錯誤信息顯示時間
        // 時間延遲配置
        RETRY_DELAY: 500,
        BASE_RETRY_DELAY: 1000,
        LOGOUT_DELAY: 1000,
        BUTTON_FEEDBACK_DELAY: 1500,
        TOAST_DISPLAY_DELAY: 3500,
        AUTO_LOGOUT_INTERVAL: 5 * 60 * 1000,
        // LocalStorage 鍵值
        AUTH_TOKEN_KEY: 'authToken',
        USER_DATA_KEY: 'userData', 
        BOOKMARKS_KEY: 'yoga_app_bookmarks',
        AUTH_STORAGE_KEY: 'yoga_app_auth',
        USER_STORAGE_KEY: 'yoga_app_user'
      };
      
      // 全局變量
      let allItems = [];
      let filteredItems = [];
      let currentUser = null;
      let currentPage = 1;
      let itemsPerPage = 5; // 步驟7: 每頁顯示5個，確保有更多數據載入
      let isLoginMode = true;
      let bookmarks = [];
      let hasMoreData = true;
      
      // 搜索、篩選和排序狀態
      let currentSearchParams = {
        search: '',
        category: 'all',
        sort: '',
        order: 'asc',
        showBookmarkedOnly: false
      };
      
      // Step 24: 無限滾動狀態 (默認啟用無限滾動)
      let isInfiniteScrollEnabled = true;
      let isLoadingMore = false;
      let autoLoadCounter = 0; // 防止無限遞歸的計數器
      const MAX_AUTO_LOADS = 5; // 最多自動載入5次
      
      // 認證和會話管理
      
      // 錯誤處理統計
      let errorStats = {
        totalErrors: 0,
        networkErrors: 0,
        serverErrors: 0,
        timeoutErrors: 0,
        lastErrorTime: null,
        consecutiveErrors: 0,
        maxConsecutiveErrors: 5
      };
      
      // API 函數 - 帶重試機制 (支持搜索、分類、排序參數)
      async function fetchFromAPIWithRetry(page = 1, limit = 5, searchParams = {}) {
        console.log('🌐 開始 API 調用:', { page, limit, searchParams });
        const maxRetries = CONFIG.MAX_RETRIES;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            // 構建URL參數
            const urlParams = new URLSearchParams();
            urlParams.append('page', page);
            urlParams.append('limit', limit);
            
            // 添加搜索參數
            if (searchParams.search && searchParams.search.trim()) {
              urlParams.append('search', searchParams.search.trim());
            }
            
            // 添加分類參數
            if (searchParams.category && searchParams.category !== '' && searchParams.category !== 'all') {
              urlParams.append('category', searchParams.category);
            }
            
            // 添加排序參數
            if (searchParams.sort) {
              urlParams.append('sort', searchParams.sort);
              if (searchParams.order) {
                urlParams.append('order', searchParams.order);
              }
            }
            
            const url = `${CONFIG.API_BASE_URL}/yoga-poses/?${urlParams.toString()}`;
            console.log(`API 嘗試 ${attempt}/${maxRetries}:`, url);
            
            // 更新載入消息
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
              loadingMessage.textContent = `載入瑜伽動作中... (嘗試 ${attempt}/${maxRetries})`;
            }
            
            const response = await fetch(url);
            
            if (!response.ok) {
              throw new Error(`HTTP 錯誤: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('API 響應:', data);
            
            // 檢查是否是測試錯誤
            if (data.error) {
              console.log('收到測試錯誤，重試中...', data.error);
              if (attempt < maxRetries) {
                await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY));
                continue;
              } else {
                throw new Error(`API 測試錯誤: ${data.error}`);
              }
            }
            
            // 成功獲取數據
            if (data.items && Array.isArray(data.items)) {
              const totalItems = data.pagination?.total || data.items.length;
              const currentTotal = (page - 1) * limit + data.items.length;
              // 修正: 更智能的檢測是否還有更多數據
              const hasMoreItems = data.pagination ? 
                (data.pagination.total > currentTotal) : 
                (data.items.length === limit); // 如果返回的項目數等於請求的限制，通常表示還有更多數據
              
              console.log('分頁信息:', {
                page,
                limit,
                itemsInResponse: data.items.length,
                totalItems,
                currentTotal,
                hasMoreItems,
                paginationData: data.pagination
              });
              
              return {
                items: data.items,
                total: totalItems,
                hasMore: hasMoreItems
              };
            } else {
              throw new Error('無效的數據格式');
            }
            
          } catch (error) {
            console.log(`嘗試 ${attempt} 失敗:`, error.message);
            
            if (attempt < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, CONFIG.BASE_RETRY_DELAY));
            } else {
              throw error;
            }
          }
        }
      }
      
      // Step 23: 收藏過濾功能
      function toggleBookmarkFilter() {
        currentSearchParams.showBookmarkedOnly = !currentSearchParams.showBookmarkedOnly;
        
        console.log('🔄 切換書籤過濾:', currentSearchParams.showBookmarkedOnly);
        console.log('📚 目前書籤數量:', bookmarks.length);
        console.log('📋 目前項目數量:', allItems.length);
        
        const filterBtn = document.getElementById('bookmark-filter-btn');
        const icon = filterBtn.querySelector('ion-icon');
        
        if (currentSearchParams.showBookmarkedOnly) {
          filterBtn.setAttribute('fill', 'solid');
          filterBtn.setAttribute('color', 'danger');
          icon.setAttribute('name', 'heart');
          filterBtn.innerHTML = '<ion-icon name="heart"></ion-icon> 只顯示收藏';
        } else {
          filterBtn.setAttribute('fill', 'outline');
          filterBtn.setAttribute('color', 'primary');
          icon.setAttribute('name', 'heart-outline');
          filterBtn.innerHTML = '<ion-icon name="heart-outline"></ion-icon> 顯示全部';
        }
        
        // 重新顯示當前項目，應用收藏過濾
        applyBookmarkFilter();
      }
      
      function applyBookmarkFilter() {
        console.log('🔍 開始收藏過濾...');
        console.log('   showBookmarkedOnly:', currentSearchParams.showBookmarkedOnly);
        console.log('   bookmarks數量:', bookmarks.length);
        console.log('   allItems數量:', allItems.length);
        
        if (currentSearchParams.showBookmarkedOnly) {
          console.log('   收藏ID列表:', bookmarks.map(b => b.id));
          console.log('   項目ID列表(前5個):', allItems.slice(0,5).map(item => item.id));
          
          // 詳細匹配檢查 - 顯示收藏的項目
          const matchedItems = [];
          allItems.forEach(item => {
            const isBookmarked = bookmarks.some(bookmark => {
              const match = parseInt(bookmark.id) === parseInt(item.id);
              if (match) {
                matchedItems.push({itemId: item.id, bookmarkId: bookmark.id, title: item.title});
              }
              return match;
            });
          });
          console.log('   匹配的收藏項目:', matchedItems);
        }
        
        const itemsToDisplay = currentSearchParams.showBookmarkedOnly 
          ? allItems.filter(item => bookmarks.some(bookmark => parseInt(bookmark.id) === parseInt(item.id)))
          : allItems;
          
        console.log(`📊 收藏過濾結果: ${itemsToDisplay.length}/${allItems.length} 項目`);
        
        // 重新顯示項目
        const list = document.getElementById('poses-list');
        list.innerHTML = '<div class="poses-grid"></div>';
        displayItems(itemsToDisplay);
        
        // 更新分頁信息
        if (currentSearchParams.showBookmarkedOnly) {
          const pagination = document.getElementById('pagination-container');
          const noMoreData = document.getElementById('no-more-data');
          const info = document.getElementById('pagination-info');
          
          noMoreData.style.display = 'none';
          info.innerHTML = `
            <strong>收藏項目: ${itemsToDisplay.length} 項</strong>
            <br>
            <small style="color: #666;">${currentUser ? '只顯示您收藏的項目' : '請登錄後收藏項目'}</small>
          `;
        } else {
          updatePaginationInfo();
        }
      }
      
      // Step 24: 無限滾動功能
      function setupInfiniteScroll() {
        // 移除舊的事件監聽器（如果存在）
        window.removeEventListener('scroll', handleInfiniteScroll);
        
        // 添加滾動事件監聽器
        window.addEventListener('scroll', handleInfiniteScroll);
        console.log('✅ 無限滾動已啟用');
      }
      
      function handleInfiniteScroll() {
        // 調試信息
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        
        console.log('📜 滾動檢測:', {
          scrollTop: Math.round(scrollTop),
          windowHeight,
          documentHeight,
          threshold: CONFIG.INFINITE_SCROLL_THRESHOLD,
          triggerPoint: documentHeight - CONFIG.INFINITE_SCROLL_THRESHOLD,
          currentPage,
          allItemsLength: allItems.length,
          isLoadingMore,
          hasMoreData,
          isInfiniteScrollEnabled,
          showBookmarkedOnly: currentSearchParams.showBookmarkedOnly
        });
        
        // 如果正在加載或禁用無限滾動，則不執行
        if (isLoadingMore || !isInfiniteScrollEnabled) {
          console.log('⚠️ 無限滾動被阻止:', { isLoadingMore, isInfiniteScrollEnabled });
          return;
        }
        
        console.log('🔍 數據狀態檢查:', {
          allItemsLength: allItems.length,
          currentPage,
          itemsPerPage,
          hasMoreData,
          '是否嘗試加載': '總是嘗試加載更多數據'
        });
        
        // 檢查是否接近頁面底部（距離底部100px時觸發，或到達底部）
        const isNearBottom = scrollTop + windowHeight >= documentHeight - CONFIG.INFINITE_SCROLL_THRESHOLD;
        const isAtBottom = scrollTop + windowHeight >= documentHeight - 10; // 距離底部10px
        
        if (isNearBottom || isAtBottom) {
          console.log('✅ 觸發無限滾動載入條件達成 - 開始載入下一頁數據');
          console.log('觸發原因:', isAtBottom ? '到達底部' : '接近底部');
          autoLoadCounter = 0; // 用戶滾動觸發的載入，重置計數器
          loadMoreDataInfinite();
        } else {
          // 添加更詳細的距離信息
          const distanceToBottom = documentHeight - (scrollTop + windowHeight);
          console.log(`距離底部還有: ${Math.round(distanceToBottom)}px`);
        }
      }
      
      async function loadMoreDataInfinite() {
        if (isLoadingMore) {
          console.log('⚠️ 正在載入中，跳過重複請求');
          return;
        }
        
        // 防止遞歸過深
        if (autoLoadCounter >= MAX_AUTO_LOADS) {
          console.log('⚠️ 自動載入已達上限，停止載入');
          return;
        }
        
        console.log('🚀 開始無限滾動載入數據');
        isLoadingMore = true;
        const infiniteLoading = document.getElementById('infinite-scroll-loading');
        const loadMoreError = document.getElementById('load-more-error');
        
        try {
          // 顯示載入指示器
          infiniteLoading.style.display = 'block';
          loadMoreError.style.display = 'none';
          
          const nextPage = currentPage + 1;
          console.log(`🔄 嘗試載入第 ${nextPage} 頁數據，當前總計: ${allItems.length} 項`);
          console.log('📋 搜索條件:', currentSearchParams);
          
          const result = await fetchFromAPIWithRetry(nextPage, itemsPerPage, currentSearchParams);
          
          if (!result.items || result.items.length === 0) {
            // 沒有更多數據
            console.log('📄 沒有更多數據可載入');
            hasMoreData = false;
            updatePaginationInfo();
            return;
          }
          
          // 更新頁數
          currentPage = nextPage;
          
          // 合併新數據
          const oldLength = allItems.length;
          allItems = [...allItems, ...result.items];
          hasMoreData = result.hasMore;
          filteredItems = [...allItems];
          
          console.log(`✅ 無限滾動載入成功: 第${currentPage}頁 | 新增 ${result.items.length} 項 | 總計 ${allItems.length} 項 | hasMore: ${result.hasMore}`);
          
          // 追加顯示新項目（不清空現有項目）
          displayItems(result.items, true);
          
          // 更新分頁信息
          updatePaginationInfo();
          
          // 如果還有更多數據且不在收藏模式，檢查是否需要繼續載入
          if (hasMoreData && !currentSearchParams.showBookmarkedOnly) {
            autoLoadCounter++; // 增加自動載入計數器
            setTimeout(() => {
              checkAndTriggerInfiniteScroll();
            }, 500);
          }
          
        } catch (error) {
          console.error('❌ 無限滾動載入失敗:', error);
          
          // 顯示錯誤信息
          loadMoreError.style.display = 'block';
          loadMoreError.innerHTML = `
            <ion-icon name="warning" style="color: #dc3545; margin-right: 5px;"></ion-icon>
            載入失敗: ${error.message} - 繼續向下滾動將自動重試
          `;
          
        } finally {
          isLoadingMore = false;
          infiniteLoading.style.display = 'none';
        }
      }
      
      function toggleInfiniteScroll() {
        isInfiniteScrollEnabled = !isInfiniteScrollEnabled;
        
        if (isInfiniteScrollEnabled) {
          setupInfiniteScroll();
          console.log('✅ 切換到無限滾動模式');
        } else {
          window.removeEventListener('scroll', handleInfiniteScroll);
          console.log('✅ 無限滾動已停用');
        }
      }
      
      // 顯示數據
      function displayItems(items, appendMode = false) {
        console.log('顯示項目:', items.length, appendMode ? '(追加模式)' : '(替換模式)');
        const list = document.getElementById('poses-list');
        const loading = document.getElementById('loading-container');
        const pagination = document.getElementById('pagination-container');
        
        if (!list) {
          console.error('找不到 poses-list 元素');
          return;
        }
        
        // 如果不是追加模式或是第一頁，清空列表
        if (!appendMode || currentPage === 1) {
          list.innerHTML = '<div class="poses-grid"></div>';
        }
        
        const grid = list.querySelector('.poses-grid');
        
        items.forEach(item => {
          const card = document.createElement('ion-card');
          card.className = 'pose-card';
          
          card.innerHTML = `
            <ion-card-header>
              <ion-card-title>${item.title || item.sanskrit_name || '無標題'}</ion-card-title>
              <ion-card-subtitle>
                ${item.category || '未分類'} • ${item.difficulty || '未設定'} • ${item.duration_minutes ? item.duration_minutes + ' 分鐘' : '未設定時長'}
              </ion-card-subtitle>
            </ion-card-header>
            
            <ion-card-content>
              ${item.image_url ? `
                <img class="item-image" src="${item.image_url}" alt="${item.title || item.sanskrit_name}" loading="lazy">
              ` : ''}
              
              <p><strong>梵文名:</strong> ${item.sanskrit_name || '無'}</p>
              <p><strong>教練:</strong> ${item.instructor || '未設定'}</p>
              <p><strong>說明:</strong> ${item.description || '無說明'}</p>
              
              ${item.benefits && Array.isArray(item.benefits) ? `
                <p><strong>好處:</strong></p>
                <ul>
                  ${item.benefits.map(benefit => `<li>${benefit}</li>`).join('')}
                </ul>
              ` : ''}
              
              ${item.video_url ? `
                <div style="margin-top: 10px;">
                  <ion-button href="${item.video_url}" target="_blank" fill="outline" size="small">
                    <ion-icon name="play-circle-outline" slot="start"></ion-icon>
                    觀看視頻
                  </ion-button>
                </div>
              ` : ''}
              
              <div style="margin-top: 10px; display: flex; justify-content: space-between; align-items: center;">
                <ion-button 
                  fill="clear" 
                  size="small" 
                  onclick="toggleBookmark(${item.id})"
                  data-item-id="${item.id}"
                  class="bookmark-btn"
                  color="medium">
                  <ion-icon name="heart-outline" slot="start"></ion-icon>
                  收藏
                </ion-button>
                
                ${currentUser ? `
                  <ion-chip color="primary" size="small">
                    <ion-icon name="person"></ion-icon>
                    <ion-label>已登錄</ion-label>
                  </ion-chip>
                ` : `
                  <ion-chip color="medium" size="small">
                    <ion-icon name="person-outline"></ion-icon>
                    <ion-label>訪客</ion-label>
                  </ion-chip>
                `}
              </div>
            </ion-card-content>
          `;
          
          grid.appendChild(card);
        });
        
        // 更新顯示狀態
        loading.style.display = 'none';
        list.style.display = 'block';
        
        // 更新書籤UI狀態
        if (currentUser) {
          updateBookmarkUI();
        }
        
        // 更新分頁信息
        updatePaginationInfo();
        pagination.style.display = 'block';
        
        console.log('數據顯示完成');
      }
      
      // 更新分頁信息
      function updatePaginationInfo() {
        const info = document.getElementById('pagination-info');
        const noMoreData = document.getElementById('no-more-data');
        const pagination = document.getElementById('pagination-container');
        
        const totalDisplayed = allItems.length;
        const pageInfo = currentPage > 1 ? ` (第 ${currentPage} 頁)` : '';
        
        info.innerHTML = `
          <strong>已顯示 ${totalDisplayed} 項瑜伽動作</strong>${pageInfo}
          <br>
          <small style="color: #666;">每頁載入 ${itemsPerPage} 項</small>
        `;
        
        console.log('更新分頁信息:', {
          totalDisplayed,
          hasMoreData,
          currentPage,
          itemsPerPage,
          pageInfo
        });
        
        // 確保分頁容器顯示
        pagination.style.display = 'block';
        
        if (hasMoreData) {
          noMoreData.style.display = 'none';
          console.log('還有更多數據，無限滾動已啟用');
        } else {
          noMoreData.style.display = 'block';
          noMoreData.innerHTML = `
            <ion-icon name="checkmark-circle" style="color: #28a745; margin-right: 8px;"></ion-icon>
            已載入所有瑜伽動作 (共 ${totalDisplayed} 項)
          `;
          console.log('顯示沒有更多數據提示');
        }
      }
      
      // 顯示錯誤
      function showError(message) {
        console.error('顯示錯誤:', message);
        const loading = document.getElementById('loading-container');
        const error = document.getElementById('error-container');
        const errorMsg = document.getElementById('error-message');
        
        loading.style.display = 'none';
        errorMsg.textContent = message;
        error.style.display = 'block';
      }
      
      // 載入數據
      async function loadData() {
        console.log('🚀 開始載入瑜伽動作數據...');
        const loading = document.getElementById('loading-container');
        const error = document.getElementById('error-container');
        const list = document.getElementById('poses-list');
        const pagination = document.getElementById('pagination-container');
        
        // 重置狀態
        currentPage = 1;
        allItems = [];
        hasMoreData = true;
        autoLoadCounter = 0; // 重置自動載入計數器
        loading.style.display = 'block';
        error.style.display = 'none';
        list.style.display = 'none';
        pagination.style.display = 'none';
        
        console.log(`載入參數: page=${currentPage}, limit=${itemsPerPage}, 搜索條件:`, currentSearchParams);
        
        try {
          const result = await fetchFromAPIWithRetry(currentPage, itemsPerPage, currentSearchParams);
          
          if (!result.items || result.items.length === 0) {
            showError('沒有找到瑜伽動作數據');
            return;
          }
          
          // 設置初始數據
          allItems = result.items;
          hasMoreData = result.hasMore;
          filteredItems = [...allItems];
          
          console.log(`✅ 首次載入成功: ${result.items.length} 項, hasMore: ${result.hasMore}`);
          
          displayItems(allItems);
          
          // Step 23: 應用收藏過濾（如果啟用）
          if (currentSearchParams.showBookmarkedOnly) {
            applyBookmarkFilter();
          }
          
          // 啟用自動觸發無限滾動檢查（如果頁面內容太少需要自動載入更多）
          console.log('✅ 數據載入完成，檢查是否需要自動載入更多內容');
          setTimeout(() => {
            checkAndTriggerInfiniteScroll();
          }, 1000); // 增加延遲確保DOM完全渲染
          
        } catch (error) {
          console.error('❌ 載入數據失敗:', error);
          showError(`載入失敗: ${error.message}`);
        }
      }
      
      // 檢測網絡狀態
      function checkNetworkStatus() {
        return navigator.onLine;
      }
      
      // 更新錯誤統計
      function updateErrorStats(error) {
        errorStats.totalErrors++;
        errorStats.lastErrorTime = new Date();
        errorStats.consecutiveErrors++;
        
        // 分類錯誤類型
        if (error.message.includes('Failed to fetch') || error.message.includes('網絡')) {
          errorStats.networkErrors++;
        } else if (error.message.includes('HTTP') && (error.message.includes('500') || error.message.includes('502') || error.message.includes('503'))) {
          errorStats.serverErrors++;
        } else if (error.message.includes('timeout') || error.message.includes('超時')) {
          errorStats.timeoutErrors++;
        }
        
        console.log('錯誤統計更新:', errorStats);
      }
      
      // 重置錯誤統計（成功載入後調用）
      function resetErrorStats() {
        errorStats.consecutiveErrors = 0;
      }
      
      // 檢查是否需要暫停重試（連續錯誤過多）
      function shouldPauseRetry() {
        return errorStats.consecutiveErrors >= errorStats.maxConsecutiveErrors;
      }
      
      // 自動重試機制（帶退避策略）
      async function autoRetryLoadMore(maxRetries = 3, baseDelay = CONFIG.BASE_RETRY_DELAY) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`嘗試自動重試載入更多數據 (${attempt}/${maxRetries})`);
            
            // 檢查網絡狀態
            if (!checkNetworkStatus()) {
              throw new Error('網絡連接不可用');
            }
            
            await loadMoreDataInfinite();
            return; // 成功則退出
            
          } catch (error) {
            console.log(`自動重試 ${attempt} 失敗:`, error.message);
            
            if (attempt === maxRetries) {
              throw error; // 所有重試都失敗
            }
            
            // 指數退避延遲
            const delay = baseDelay * Math.pow(2, attempt - 1);
            console.log(`等待 ${delay}ms 後重試...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }
      
      // 手動重試載入更多數據
      async function retryLoadMore() {
        const loadMoreError = document.getElementById('load-more-error');
        
        try {
          loadMoreError.style.display = 'none';
          
          console.log('手動重試載入更多數據');
          await loadMoreDataInfinite();
          
        } catch (error) {
          console.error('手動重試失敗:', error);
          
          // 顯示重試失敗信息
          loadMoreError.style.display = 'block';
          loadMoreError.innerHTML = `
            <div style="color: #dc3545; padding: 8px; text-align: center;">
              <ion-icon name="alert-circle" style="margin-right: 4px;"></ion-icon>
              重試失敗: ${error.message} - 繼續向下滾動將自動重試
            </div>
          `;
        }
      }
      
      // 檢查並觸發無限滾動（用於頁面內容太少的情況）
      function checkAndTriggerInfiniteScroll() {
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        
        console.log('檢查是否需要自動載入更多:', {
          windowHeight,
          documentHeight,
          hasMoreData,
          isInfiniteScrollEnabled,
          autoLoadCounter,
          ratio: documentHeight / windowHeight
        });
        
        // 防止無限遞歸：檢查自動載入計數器
        if (autoLoadCounter >= MAX_AUTO_LOADS) {
          console.log('⚠️ 已達到最大自動載入次數，停止自動載入');
          return;
        }
        
        // 如果頁面內容太少（小於視窗高度的1.5倍），且還有更多數據，則自動載入
        if (documentHeight < windowHeight * 1.5 && hasMoreData && isInfiniteScrollEnabled && !isLoadingMore) {
          console.log('🔄 頁面內容太少，自動觸發載入更多數據');
          autoLoadCounter++; // 增加計數器
          loadMoreDataInfinite();
        }
      }

      // API搜索功能 - Step 20
      let searchTimeout = null;
      
      async function performAPISearch() {
        // 清除之前的搜索延遲
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }
        
        // 延遲執行搜索，避免頻繁API調用
        searchTimeout = setTimeout(async () => {
          const searchTerm = document.getElementById('search-bar').value.trim();
          const selectedCategory = document.getElementById('category-select').value;
          const selectedSort = document.getElementById('sort-select').value;
          const selectedOrder = document.getElementById('order-select').value;
          
          // 更新搜索參數
          currentSearchParams.search = searchTerm;
          currentSearchParams.category = selectedCategory;
          currentSearchParams.sort = selectedSort;
          currentSearchParams.order = selectedOrder;
          
          console.log('執行API搜索:', currentSearchParams);
          
          // 如果有搜索條件，重新載入數據
          if (searchTerm || (selectedCategory && selectedCategory !== '') || selectedSort) {
            await loadData();
          } else {
            // 如果清空所有搜索條件，也重新載入數據
            await loadData();
          }
        }, 500);
      }
      
      // 認證相關功能（簡化版）
      function openAuthModal() {
        document.getElementById('auth-modal').present();
      }
      
      function closeAuthModal() {
        document.getElementById('auth-modal').dismiss();
      }
      
      function closeLogoutModal() {
        document.getElementById('logout-confirm-modal').dismiss();
      }
      
      // Step 25: 增強表單驗證工具函數
      function validateEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      }
      
      function validatePassword(password) {
        // 至少8個字符，包含大寫字母、小寫字母、數字
        const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/;
        return passwordRegex.test(password);
      }
      
      // Step 25: 密碼強度檢查（詳細分析）
      function getPasswordStrength(password) {
        const checks = {
          length: password.length >= 8,
          lowercase: /[a-z]/.test(password),
          uppercase: /[A-Z]/.test(password),
          numbers: /\d/.test(password),
          special: /[@$!%*?&]/.test(password),
          noSpaces: !/\s/.test(password)
        };
        
        const passedChecks = Object.values(checks).filter(Boolean).length;
        let strength = 'weak';
        let score = 0;
        
        if (checks.length) score += 2;
        if (checks.lowercase) score += 1;
        if (checks.uppercase) score += 1;
        if (checks.numbers) score += 1;
        if (checks.special) score += 2;
        if (checks.noSpaces) score += 1;
        
        if (score >= 7) strength = 'strong';
        else if (score >= 5) strength = 'medium';
        
        return {
          strength,
          score,
          checks,
          isValid: checks.length && checks.lowercase && checks.uppercase && checks.numbers && checks.noSpaces
        };
      }
      
      function validateUsername(username) {
        // 用戶名：3-20個字符，只能包含字母、數字、下劃線
        const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;
        return usernameRegex.test(username);
      }
      
      // Step 25: 實時密碼強度檢查和視覺反饋
      function updatePasswordStrength(password) {
        const strengthContainer = document.getElementById('password-strength-container');
        const strengthFill = document.getElementById('password-strength-fill');
        const strengthText = document.getElementById('password-strength-text');
        
        if (!password || password.length === 0) {
          strengthContainer.style.display = 'none';
          return;
        }
        
        strengthContainer.style.display = 'block';
        const analysis = getPasswordStrength(password);
        
        // 更新強度條
        let width = 0;
        let color = '#dc3545'; // 紅色 (弱)
        let text = '弱';
        
        if (analysis.strength === 'strong') {
          width = 100;
          color = '#28a745'; // 綠色 (強)
          text = '強';
        } else if (analysis.strength === 'medium') {
          width = 66;
          color = '#ffc107'; // 黃色 (中等)
          text = '中等';
        } else {
          width = 33;
          color = '#dc3545'; // 紅色 (弱)
          text = '弱';
        }
        
        strengthFill.style.width = width + '%';
        strengthFill.style.backgroundColor = color;
        strengthText.textContent = text;
        strengthText.style.color = color;
        
        // 更新需求檢查列表
        updateRequirementChecklist(analysis.checks);
      }
      
      function updateRequirementChecklist(checks) {
        const requirements = [
          { id: 'req-length', check: checks.length, text: '至少8個字符' },
          { id: 'req-lowercase', check: checks.lowercase, text: '包含小寫字母' },
          { id: 'req-uppercase', check: checks.uppercase, text: '包含大寫字母' },
          { id: 'req-numbers', check: checks.numbers, text: '包含數字' },
          { id: 'req-special', check: checks.special, text: '包含特殊字符 (可選)' }
        ];
        
        requirements.forEach(req => {
          const element = document.getElementById(req.id);
          if (element) {
            if (req.check) {
              element.innerHTML = `<span style="color: #28a745;">✓</span> ${req.text}`;
            } else if (req.id === 'req-special') {
              element.innerHTML = `<span style="color: #6c757d;">○</span> ${req.text}`;
            } else {
              element.innerHTML = `<span style="color: #dc3545;">✗</span> ${req.text}`;
            }
          }
        });
      }
      
      function showFieldError(fieldId, message) {
        const errorElement = document.getElementById(fieldId + '-error');
        if (errorElement) {
          errorElement.textContent = message;
          errorElement.classList.add('show');
        }
      }
      
      function hideFieldError(fieldId) {
        const errorElement = document.getElementById(fieldId + '-error');
        if (errorElement) {
          errorElement.classList.remove('show');
        }
      }
      
      function showAuthError(message) {
        const errorElement = document.getElementById('auth-error');
        errorElement.innerHTML = `
          <div style="display: flex; align-items: center;">
            <ion-icon name="alert-circle" style="margin-right: 8px; color: #dc3545;"></ion-icon>
            <span>${message}</span>
          </div>
        `;
        errorElement.classList.add('show');
        
        // 5秒後自動隱藏
        setTimeout(() => {
          errorElement.classList.remove('show');
        }, CONFIG.ERROR_DISPLAY_TIMEOUT);
      }
      
      function hideAuthError() {
        const errorElement = document.getElementById('auth-error');
        errorElement.classList.remove('show');
      }
      
      // 表單驗證函數
      function validateLoginForm() {
        let isValid = true;
        
        const username = document.getElementById('login-username').value.trim();
        const password = document.getElementById('login-password').value;
        
        // 清除之前的錯誤
        hideFieldError('login-username');
        hideFieldError('login-password');
        hideAuthError();
        
        // 驗證用戶名/郵件
        if (!username) {
          showFieldError('login-username', '請輸入用戶名或郵件');
          isValid = false;
        } else if (username.length < 3) {
          showFieldError('login-username', '用戶名至少3個字符');
          isValid = false;
        }
        
        // 驗證密碼
        if (!password) {
          showFieldError('login-password', '請輸入密碼');
          isValid = false;
        } else if (password.length < 6) {
          showFieldError('login-password', '密碼至少6個字符');
          isValid = false;
        }
        
        return isValid;
      }
      
      function validateRegisterForm() {
        let isValid = true;
        
        const username = document.getElementById('register-username').value.trim();
        const email = document.getElementById('register-email').value.trim();
        const password = document.getElementById('register-password').value;
        const confirmPassword = document.getElementById('register-confirm-password').value;
        
        // 清除之前的錯誤
        hideFieldError('register-username');
        hideFieldError('register-email');
        hideFieldError('register-password');
        hideFieldError('register-confirm-password');
        hideAuthError();
        
        // 驗證用戶名
        if (!username) {
          showFieldError('register-username', '請輸入用戶名');
          isValid = false;
        } else if (!validateUsername(username)) {
          showFieldError('register-username', '用戶名：3-20個字符，只能包含字母、數字、下劃線');
          isValid = false;
        }
        
        // 驗證郵件
        if (!email) {
          showFieldError('register-email', '請輸入電子郵件');
          isValid = false;
        } else if (!validateEmail(email)) {
          showFieldError('register-email', '請輸入有效的電子郵件地址');
          isValid = false;
        }
        
        // Step 25: 驗證密碼（使用增強版檢查）
        if (!password) {
          showFieldError('register-password', '請輸入密碼');
          isValid = false;
        } else {
          const passwordStrength = getPasswordStrength(password);
          if (!passwordStrength.isValid) {
            showFieldError('register-password', '密碼必須至少8位，包含大寫字母、小寫字母、數字且無空格');
            isValid = false;
          }
        }
        
        // 驗證確認密碼
        if (!confirmPassword) {
          showFieldError('register-confirm-password', '請確認密碼');
          isValid = false;
        } else if (password !== confirmPassword) {
          showFieldError('register-confirm-password', '兩次輸入的密碼不一致');
          isValid = false;
        }
        
        return isValid;
      }
      
      // 切換表單模式
      function switchAuthMode(mode) {
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        const title = document.getElementById('auth-title');
        
        if (mode === 'login') {
          loginForm.style.display = 'block';
          registerForm.style.display = 'none';
          title.textContent = '登錄';
        } else {
          loginForm.style.display = 'none';
          registerForm.style.display = 'block';
          title.textContent = '註冊';
        }
        
        // 清除所有錯誤信息
        hideAuthError();
        hideFieldError('login-username');
        hideFieldError('login-password');
        hideFieldError('register-username');
        hideFieldError('register-email');
        hideFieldError('register-password');
        hideFieldError('register-confirm-password');
      }
      
      // 處理登錄
      async function handleLogin(event) {
        event.preventDefault();
        
        if (!validateLoginForm()) {
          return;
        }
        
        const loginBtn = document.getElementById('login-submit-btn');
        const btnText = document.getElementById('login-btn-text');
        
        try {
          // 顯示載入狀態
          loginBtn.disabled = true;
          btnText.innerHTML = '<ion-spinner class="loading-spinner"></ion-spinner>登錄中...';
          
          const username = document.getElementById('login-username').value.trim();
          const password = document.getElementById('login-password').value;
          
          // 調用真實API（帶重試機制）
          const response = await loginUser(username, password);
          
          // 處理登入成功回應
          let user, token;
          
          if (response.user) {
            // 如果API返回完整用戶數據
            user = response.user;
            token = response.token || response.access_token;
          } else {
            // 如果API只返回基本信息，構建用戶對象
            user = {
              id: response.id || response.user_id || Date.now(),
              username: response.username || username,
              email: response.email || null,
              name: response.name || response.display_name || username,
              avatar: response.avatar || null,
              role: response.role || 'user',
              createdAt: response.created_at || new Date().toISOString()
            };
            token = response.token || response.access_token;
          }
          
          // 登錄成功
          currentUser = user;
          saveAuthSession(currentUser, token);
          
          // 初始化用戶數據
          await initializeUserData();
          
          // 更新UI
          updateUserUI();
          closeAuthModal();
          
          // 清空表單
          document.getElementById('login-form').reset();
          
          // 顯示歡迎消息
          showSuccessMessage(`歡迎回來，${getUserDisplayName()}！`);
          
        } catch (error) {
          showAuthError(error.message);
        } finally {
          // 恢復按鈕狀態
          loginBtn.disabled = false;
          btnText.textContent = '登錄';
        }
      }
      
      // 處理註冊
      async function handleRegister(event) {
        event.preventDefault();
        
        if (!validateRegisterForm()) {
          return;
        }
        
        const registerBtn = document.getElementById('register-submit-btn');
        const btnText = document.getElementById('register-btn-text');
        
        try {
          // 顯示載入狀態
          registerBtn.disabled = true;
          btnText.innerHTML = '<ion-spinner class="loading-spinner"></ion-spinner>註冊中...';
          
          const username = document.getElementById('register-username').value.trim();
          const email = document.getElementById('register-email').value.trim();
          const password = document.getElementById('register-password').value;
          
          // 調用真實API（帶重試機制）
          const response = await signupUser(username, email, password);
          
          // 處理註冊成功回應
          let user, token;
          
          if (response.user) {
            // 如果API返回完整用戶數據
            user = response.user;
            token = response.token || response.access_token;
          } else {
            // 如果API只返回基本信息，構建用戶對象
            user = {
              id: response.id || Date.now(),
              username: username,
              email: email,
              name: response.name || username,
              avatar: response.avatar || null,
              role: response.role || 'user',
              createdAt: response.created_at || new Date().toISOString()
            };
            token = response.token || response.access_token;
          }
          
          // 註冊成功，保存會話
          currentUser = user;
          saveAuthSession(currentUser, token);
          
          // 初始化用戶數據
          await initializeUserData();
          
          // 更新UI
          updateUserUI();
          closeAuthModal();
          
          // 清空表單
          document.getElementById('register-form').reset();
          
          // 顯示歡迎消息
          showSuccessMessage(`註冊成功！歡迎加入，${getUserDisplayName()}！`);
          
        } catch (error) {
          showAuthError(error.message);
        } finally {
          // 恢復按鈕狀態
          registerBtn.disabled = false;
          btnText.textContent = '註冊';
        }
      }
      
      // 會話管理函數
      function saveAuthSession(user, token = null) {
        const authData = {
          user: user,
          token: token,
          timestamp: Date.now(),
          expiresAt: Date.now() + CONFIG.SESSION_TIMEOUT
        };
        
        localStorage.setItem(CONFIG.AUTH_STORAGE_KEY, JSON.stringify(authData));
        localStorage.setItem(CONFIG.USER_STORAGE_KEY, JSON.stringify(user));
        
        console.log('會話已保存:', authData);
      }
      
      function loadAuthSession() {
        try {
          const authData = localStorage.getItem(CONFIG.AUTH_STORAGE_KEY);
          if (!authData) return null;
          
          const session = JSON.parse(authData);
          
          // 檢查會話是否過期
          if (Date.now() > session.expiresAt) {
            clearAuthSession();
            return null;
          }
          
          return session;
        } catch (error) {
          console.error('載入會話失敗:', error);
          clearAuthSession();
          return null;
        }
      }
      
      function clearAuthSession() {
        localStorage.removeItem(CONFIG.AUTH_STORAGE_KEY);
        localStorage.removeItem(CONFIG.USER_STORAGE_KEY);
        currentUser = null;
        console.log('會話已清除');
      }
      
      function isSessionValid() {
        const session = loadAuthSession();
        return session && Date.now() < session.expiresAt;
      }
      
      function refreshSession() {
        const session = loadAuthSession();
        if (session) {
          session.timestamp = Date.now();
          session.expiresAt = Date.now() + CONFIG.SESSION_TIMEOUT;
          localStorage.setItem(CONFIG.AUTH_STORAGE_KEY, JSON.stringify(session));
        }
      }
      
      // 真實API登錄函數 - 帶重試機制
      async function loginUser(username, password, maxRetries = 3) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`登錄嘗試 ${attempt}/${maxRetries}`);
            
            const response = await fetch('https://dae-mobile-assignment.hkit.cc/api/auth/login', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                username: username,
                password: password
              })
            });

            const data = await response.json();
            
            // 檢查是否是測試錯誤（可以重試）
            if (data.error && data.error.includes('Error injected for testing purposes')) {
              console.log(`收到測試錯誤，第 ${attempt} 次嘗試失敗，準備重試...`);
              if (attempt < maxRetries) {
                // 指數退避延遲
                const delay = Math.pow(2, attempt - 1) * 1000;
                console.log(`等待 ${delay}ms 後重試...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
              }
            }
            
            // 檢查其他錯誤
            if (!response.ok || data.error) {
              throw new Error(data.message || data.error || `登錄失敗 (HTTP ${response.status})`);
            }

            console.log(`登錄成功！第 ${attempt} 次嘗試`);
            return data;
            
          } catch (error) {
            console.error(`登錄API錯誤 (嘗試 ${attempt}/${maxRetries}):`, error);
            
            // 如果是最後一次嘗試，拋出錯誤
            if (attempt === maxRetries) {
              throw error;
            }
            
            // 否則等待後重試
            const delay = Math.pow(2, attempt - 1) * 1000;
            console.log(`等待 ${delay}ms 後重試...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }

      // 真實API註冊函數 - 帶重試機制
      async function signupUser(username, email, password, maxRetries = 3) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`註冊嘗試 ${attempt}/${maxRetries}`);
            
            const response = await fetch('https://dae-mobile-assignment.hkit.cc/api/auth/signup', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                username: username,
                email: email,
                password: password
              })
            });

            const data = await response.json();
            
            // 檢查是否是測試錯誤（可以重試）
            if (data.error && data.error.includes('Error injected for testing purposes')) {
              console.log(`收到測試錯誤，第 ${attempt} 次嘗試失敗，準備重試...`);
              if (attempt < maxRetries) {
                // 指數退避延遲
                const delay = Math.pow(2, attempt - 1) * 1000;
                console.log(`等待 ${delay}ms 後重試...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
              }
            }
            
            // 檢查其他錯誤
            if (!response.ok || data.error) {
              throw new Error(data.message || data.error || `註冊失敗 (HTTP ${response.status})`);
            }

            console.log(`註冊成功！第 ${attempt} 次嘗試`);
            return data;
            
          } catch (error) {
            console.error(`註冊API錯誤 (嘗試 ${attempt}/${maxRetries}):`, error);
            
            // 如果是最後一次嘗試，拋出錯誤
            if (attempt === maxRetries) {
              throw error;
            }
            
            // 否則等待後重試
            const delay = Math.pow(2, attempt - 1) * 1000;
            console.log(`等待 ${delay}ms 後重試...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }

      // 模擬登錄API（稍後替換）
      async function simulateLogin(username, password) {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            // 模擬API響應 - 演示用戶：demo/demo123
            if (username === 'demo' && password === 'demo123') {
              const user = { 
                id: 1,
                username, 
                email: 'demo@example.com',
                name: 'Demo User',
                avatar: null,
                role: 'user'
              };
              resolve({ 
                success: true, 
                user: user,
                token: 'demo_token_' + Date.now()
              });
            } else if (username === 'admin' && password === 'admin123') {
              const user = { 
                id: 2,
                username, 
                email: 'admin@example.com',
                name: 'Admin User',
                avatar: null,
                role: 'admin'
              };
              resolve({ 
                success: true, 
                user: user,
                token: 'admin_token_' + Date.now()
              });
            } else {
              reject(new Error('用戶名或密碼錯誤'));
            }
          }, CONFIG.LOGOUT_DELAY);
        });
      }
      
      // 模擬註冊API（稍後替換）
      async function simulateRegister(username, email, password) {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            // 模擬註冊驗證
            if (username === 'existing') {
              reject(new Error('用戶名已存在'));
            } else if (email === 'existing@example.com') {
              reject(new Error('郵件地址已被註冊'));
            } else {
              const user = {
                id: Date.now(), // 簡單的ID生成
                username,
                email,
                name: username,
                avatar: null,
                role: 'user',
                createdAt: new Date().toISOString()
              };
              resolve({ 
                success: true, 
                user: user,
                token: 'new_user_token_' + Date.now()
              });
            }
          }, CONFIG.BUTTON_FEEDBACK_DELAY);
        });
      }
      
      // 用戶信息管理
      function updateUserProfile(updates) {
        if (currentUser) {
          currentUser = { ...currentUser, ...updates };
          localStorage.setItem(CONFIG.USER_STORAGE_KEY, JSON.stringify(currentUser));
          
          // 更新會話中的用戶信息
          const session = loadAuthSession();
          if (session) {
            session.user = currentUser;
            localStorage.setItem(CONFIG.AUTH_STORAGE_KEY, JSON.stringify(session));
          }
        }
      }
      
      function getUserDisplayName() {
        if (!currentUser) return '訪客';
        return currentUser.name || currentUser.username || currentUser.email;
      }
      
      // 書籤管理 - API 收藏功能
      
      // 添加收藏 API 調用
      async function addBookmark(itemId, maxRetries = 3) {
        if (!currentUser) {
          throw new Error('請先登錄以使用收藏功能');
        }
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`添加收藏嘗試 ${attempt}/${maxRetries} - Item ID: ${itemId}`);
            
            const session = loadAuthSession();
            const token = session ? session.token : null;
            
            const response = await fetch(`${CONFIG.API_BASE_URL}/bookmarks/${itemId}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': token ? `Bearer ${token}` : ''
              },
              body: JSON.stringify({
                item_id: itemId
              })
            });

            const data = await response.json();
            
            // 檢查是否是測試錯誤（可以重試）
            if (data.error && data.error.includes('Error injected for testing purposes')) {
              console.log(`收到測試錯誤，第 ${attempt} 次嘗試失敗，準備重試...`);
              if (attempt < maxRetries) {
                const delay = Math.pow(2, attempt - 1) * 1000;
                console.log(`等待 ${delay}ms 後重試...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
              }
            }
            
            // 檢查其他錯誤
            if (!response.ok || data.error) {
              throw new Error(data.message || data.error || `添加收藏失敗 (HTTP ${response.status})`);
            }

            console.log(`收藏添加成功！第 ${attempt} 次嘗試`);
            return data;
            
          } catch (error) {
            console.error(`添加收藏API錯誤 (嘗試 ${attempt}/${maxRetries}):`, error);
            
            if (attempt === maxRetries) {
              throw error;
            }
            
            const delay = Math.pow(2, attempt - 1) * 1000;
            console.log(`等待 ${delay}ms 後重試...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }
      
      // 移除收藏 API 調用
      async function removeBookmark(itemId, maxRetries = 3) {
        if (!currentUser) {
          throw new Error('請先登錄以使用收藏功能');
        }
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`移除收藏嘗試 ${attempt}/${maxRetries} - Item ID: ${itemId}`);
            
            const session = loadAuthSession();
            const token = session ? session.token : null;
            
            const response = await fetch(`${CONFIG.API_BASE_URL}/bookmarks/${itemId}`, {
              method: 'DELETE',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': token ? `Bearer ${token}` : ''
              }
            });

            const data = await response.json();
            
            // 檢查是否是測試錯誤（可以重試）
            if (data.error && data.error.includes('Error injected for testing purposes')) {
              console.log(`收到測試錯誤，第 ${attempt} 次嘗試失敗，準備重試...`);
              if (attempt < maxRetries) {
                const delay = Math.pow(2, attempt - 1) * 1000;
                console.log(`等待 ${delay}ms 後重試...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
              }
            }
            
            // 檢查其他錯誤
            if (!response.ok || data.error) {
              throw new Error(data.message || data.error || `移除收藏失敗 (HTTP ${response.status})`);
            }

            console.log(`收藏移除成功！第 ${attempt} 次嘗試`);
            return data;
            
          } catch (error) {
            console.error(`移除收藏API錯誤 (嘗試 ${attempt}/${maxRetries}):`, error);
            
            if (attempt === maxRetries) {
              throw error;
            }
            
            const delay = Math.pow(2, attempt - 1) * 1000;
            console.log(`等待 ${delay}ms 後重試...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }
      
      // 獲取用戶收藏列表 API 調用
      async function fetchUserBookmarks(maxRetries = 3) {
        if (!currentUser) {
          console.log('用戶未登錄，無法獲取收藏列表');
          return [];
        }
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`獲取收藏列表嘗試 ${attempt}/${maxRetries}`);
            
            const session = loadAuthSession();
            const token = session ? session.token : null;
            
            const response = await fetch(`${CONFIG.API_BASE_URL}/bookmarks`, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': token ? `Bearer ${token}` : ''
              }
            });

            const data = await response.json();
            
            // 檢查是否是測試錯誤（可以重試）
            if (data.error && data.error.includes('Error injected for testing purposes')) {
              console.log(`收到測試錯誤，第 ${attempt} 次嘗試失敗，準備重試...`);
              if (attempt < maxRetries) {
                const delay = Math.pow(2, attempt - 1) * 1000;
                console.log(`等待 ${delay}ms 後重試...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
              }
            }
            
            // 檢查其他錯誤
            if (!response.ok || data.error) {
              console.warn(`獲取收藏列表失敗: ${data.message || data.error || `HTTP ${response.status}`}`);
              return []; // 失敗時返回空數組
            }

            console.log(`收藏列表獲取成功！第 ${attempt} 次嘗試`);
            return data.bookmarks || data || [];
            
          } catch (error) {
            console.error(`獲取收藏列表API錯誤 (嘗試 ${attempt}/${maxRetries}):`, error);
            
            if (attempt === maxRetries) {
              console.warn('獲取收藏列表失敗，使用本地緩存');
              return []; // 最終失敗時返回空數組
            }
            
            const delay = Math.pow(2, attempt - 1) * 1000;
            console.log(`等待 ${delay}ms 後重試...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
        
        return [];
      }
      
      // 初始化用戶數據（登錄/註冊成功後調用）
      async function initializeUserData() {
        if (!currentUser) return;
        
        try {
          console.log('正在初始化用戶數據...');
          
          // 先加載本地收藏作為備用
          const localBookmarks = loadUserBookmarks();
          
          // 嘗試從API加載收藏列表
          const apiBookmarks = await fetchUserBookmarks();
          
          if (apiBookmarks && apiBookmarks.length > 0) {
            console.log(`從API加載了 ${apiBookmarks.length} 個收藏`);
            bookmarks = apiBookmarks;
            
            // 將API數據保存到本地作為備份
            saveUserBookmarks(bookmarks);
          } else {
            console.log('API沒有返回收藏數據，使用本地收藏');
            bookmarks = localBookmarks;
          }
          
          // 更新UI
          updateBookmarkUI();
          
        } catch (error) {
          console.error('初始化用戶數據失敗:', error);
          
          // 使用本地收藏作為後備
          bookmarks = loadUserBookmarks();
          updateBookmarkUI();
        }
      }
      
      // 本地書籤管理（作為API的後備）
      function loadUserBookmarks() {
        if (!currentUser) return [];
        
        try {
          const bookmarksData = localStorage.getItem(CONFIG.BOOKMARKS_KEY + '_' + currentUser.id);
          return bookmarksData ? JSON.parse(bookmarksData) : [];
        } catch (error) {
          console.error('載入書籤失敗:', error);
          return [];
        }
      }
      
      function saveUserBookmarks(bookmarkList) {
        if (!currentUser) return;
        
        try {
          localStorage.setItem(CONFIG.BOOKMARKS_KEY + '_' + currentUser.id, JSON.stringify(bookmarkList));
          bookmarks = bookmarkList;
        } catch (error) {
          console.error('保存書籤失敗:', error);
        }
      }
      
      // 收藏切換功能（使用真實API）
      async function toggleBookmark(itemId) {
        if (!currentUser) {
          showAuthError('請先登錄以使用收藏功能');
          return false;
        }
        
        const bookmarkIndex = bookmarks.findIndex(b => parseInt(b.id) === parseInt(itemId));
        const isCurrentlyBookmarked = bookmarkIndex > -1;
        
        // 更新UI狀態（樂觀更新）
        const bookmarkBtn = document.querySelector(`[data-item-id="${itemId}"] .bookmark-btn`);
        if (bookmarkBtn) {
          bookmarkBtn.disabled = true;
          bookmarkBtn.innerHTML = '<ion-spinner name="crescent"></ion-spinner>';
        }
        
        try {
          if (isCurrentlyBookmarked) {
            // 移除收藏
            await removeBookmark(itemId);
            
            // 從本地列表移除
            bookmarks.splice(bookmarkIndex, 1);
            showSuccessMessage('已移除收藏');
          } else {
            // 添加收藏
            await addBookmark(itemId);
            
            // 添加到本地列表
            const item = allItems.find(i => parseInt(i.id) === parseInt(itemId));
            if (item) {
              bookmarks.push({
                id: parseInt(itemId), // 確保 ID 是數字
                title: item.title || item.sanskrit_name || '無標題',
                addedAt: new Date().toISOString()
              });
              console.log('✅ 已添加書籤:', {id: parseInt(itemId), title: item.title || item.sanskrit_name});
            } else {
              console.error('❌ 找不到要收藏的項目:', itemId, '在', allItems.length, '個項目中');
            }
            showSuccessMessage('已加入收藏');
          }
          
          // 保存到本地存儲（作為備份）
          saveUserBookmarks(bookmarks);
          updateBookmarkUI();
          return true;
          
        } catch (error) {
          console.error('收藏操作失敗:', error);
          showAuthError(`收藏操作失敗: ${error.message}`);
          
          // 恢復UI狀態
          updateBookmarkUI();
          return false;
        }
      }

      // UI更新函數
      function updateUserUI() {
        const authBtn = document.getElementById('auth-btn');
        
        if (currentUser) {
          authBtn.textContent = `${getUserDisplayName()} ▼`;
          authBtn.style.maxWidth = '150px';
          authBtn.style.overflow = 'hidden';
          authBtn.style.textOverflow = 'ellipsis';
          
          // 顯示用戶相關功能
          updateBookmarkUI();
        } else {
          authBtn.textContent = '登入';
          authBtn.style.maxWidth = 'none';
          authBtn.style.overflow = 'visible';
          authBtn.style.textOverflow = 'unset';
          
          // 登出時也要更新收藏按鈕狀態
          updateBookmarkUI();
        }
      }
      
      function updateBookmarkUI() {
        // 更新所有收藏按鈕狀態
        const bookmarkBtns = document.querySelectorAll('.bookmark-btn');
        bookmarkBtns.forEach(btn => {
          const itemId = parseInt(btn.getAttribute('data-item-id'));
          const isBookmarked = bookmarks.some(b => parseInt(b.id) === itemId);
          
          // 重置按鈕狀態
          btn.disabled = false;
          
          if (isBookmarked) {
            // 已收藏狀態
            btn.setAttribute('fill', 'solid');
            btn.setAttribute('color', 'danger');
            btn.innerHTML = '<ion-icon name="heart" slot="start"></ion-icon>已收藏';
          } else {
            // 未收藏狀態
            btn.setAttribute('fill', 'clear');
            btn.setAttribute('color', 'medium');
            btn.innerHTML = '<ion-icon name="heart-outline" slot="start"></ion-icon>收藏';
          }
        });
        
        console.log(`更新了 ${bookmarkBtns.length} 個收藏按鈕，當前收藏數: ${bookmarks.length}`);
        
        // Step 23: 如果啟用了收藏過濾，重新應用過濾
        if (currentSearchParams.showBookmarkedOnly) {
          applyBookmarkFilter();
        }
      }
      
      function showSuccessMessage(message) {
        // 創建成功提示
        const toast = document.createElement('ion-toast');
        toast.message = message;
        toast.duration = 3000;
        toast.color = 'success';
        toast.position = 'top';
        
        document.body.appendChild(toast);
        toast.present();
        
        // 自動移除元素
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, CONFIG.TOAST_DISPLAY_DELAY);
      }
      
      function confirmLogout() {
        // 清除會話
        clearAuthSession();
        
        // 清空書籤
        bookmarks = [];
        
        // 更新UI
        updateUserUI();
        
        // 重要：更新收藏按鈕狀態，移除所有收藏標示
        updateBookmarkUI();
        
        closeLogoutModal();
        
        // 顯示登出消息
        showSuccessMessage('已成功登出');
      }
      
      // 初始化應用
      document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM 已加載，開始初始化...');
        
        // 檢查並載入現有會話
        const existingSession = loadAuthSession();
        if (existingSession && isSessionValid()) {
          currentUser = existingSession.user;
          updateUserUI();
          console.log('已載入現有會話:', currentUser);
          
          // 異步初始化用戶數據
          initializeUserData().catch(error => {
            console.error('初始化用戶數據失敗:', error);
          });
        }
        
        // 設置會話自動刷新（每5分鐘）
        setInterval(() => {
          if (currentUser && isSessionValid()) {
            refreshSession();
          }
        }, CONFIG.AUTO_LOGOUT_INTERVAL);
        
        // 強制設置 itemsPerPage 為 5 (避免初始化問題)
        itemsPerPage = 5;
        console.log('🔧 強制設置 itemsPerPage =', itemsPerPage);
        
        // 設置事件監聽器 - Step 20: API搜索, Step 22: 排序功能
        document.getElementById('search-bar').addEventListener('ionInput', performAPISearch);
        document.getElementById('category-select').addEventListener('ionChange', performAPISearch);
        document.getElementById('sort-select').addEventListener('ionChange', performAPISearch);
        document.getElementById('order-select').addEventListener('ionChange', performAPISearch);
        
        // 延遲初始化下拉選單事件監聽器
        setTimeout(() => {
          const limitSelect = document.getElementById('limit-select');
          if (limitSelect) {
            // 同步下拉選單值
            if (limitSelect.value && parseInt(limitSelect.value) !== itemsPerPage) {
              itemsPerPage = parseInt(limitSelect.value) || 5;
              console.log('📝 從選單同步 itemsPerPage =', itemsPerPage);
            }
            
            limitSelect.addEventListener('ionChange', (e) => {
              itemsPerPage = parseInt(e.detail.value);
              console.log('itemsPerPage 已更新為:', itemsPerPage);
              loadData(); // 重新載入數據
            });
          }
        }, 200);
        
        document.getElementById('auth-btn').addEventListener('click', () => {
          if (currentUser) {
            document.getElementById('logout-confirm-modal').present();
          } else {
            openAuthModal();
          }
        });
        
        // 設置認證表單事件監聽器
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        const switchToRegister = document.getElementById('switch-to-register');
        const switchToLogin = document.getElementById('switch-to-login');
        
        // 表單提交事件
        if (loginForm) {
          loginForm.addEventListener('submit', handleLogin);
        }
        
        if (registerForm) {
          registerForm.addEventListener('submit', handleRegister);
        }
        
        // 表單切換事件
        if (switchToRegister) {
          switchToRegister.addEventListener('click', () => switchAuthMode('register'));
        }
        
        if (switchToLogin) {
          switchToLogin.addEventListener('click', () => switchAuthMode('login'));
        }
        
        // 設置輸入框聚焦效果
        const allInputs = document.querySelectorAll('#auth-form-container ion-input');
        allInputs.forEach(input => {
          const item = input.closest('ion-item');
          
          // 添加聚焦效果
          input.addEventListener('ionFocus', () => {
            item.classList.add('item-has-focus');
            // 清除佔位符（通過設置為空）
            const placeholder = input.getAttribute('placeholder');
            if (placeholder) {
              input.setAttribute('data-original-placeholder', placeholder);
              input.setAttribute('placeholder', '');
            }
          });
          
          // 移除聚焦效果
          input.addEventListener('ionBlur', () => {
            item.classList.remove('item-has-focus');
            // 如果輸入框為空，恢復佔位符
            const value = input.value?.trim();
            if (!value) {
              const originalPlaceholder = input.getAttribute('data-original-placeholder');
              if (originalPlaceholder) {
                input.setAttribute('placeholder', originalPlaceholder);
              }
            }
          });
        });
        
        // 實時驗證事件
        const loginUsername = document.getElementById('login-username');
        if (loginUsername) {
          loginUsername.addEventListener('ionBlur', () => {
            const value = loginUsername.value.trim();
            if (value && value.length < 3) {
              showFieldError('login-username', '用戶名至少3個字符');
            } else {
              hideFieldError('login-username');
            }
          });
        }
        
        const registerEmail = document.getElementById('register-email');
        if (registerEmail) {
          registerEmail.addEventListener('ionBlur', () => {
            const value = registerEmail.value.trim();
            if (value && !validateEmail(value)) {
              showFieldError('register-email', '請輸入有效的電子郵件地址');
            } else {
              hideFieldError('register-email');
            }
          });
        }
        
        const registerPassword = document.getElementById('register-password');
        if (registerPassword) {
          registerPassword.addEventListener('ionInput', () => {
            const value = registerPassword.value;
            
            // Step 25: 實時密碼強度檢查
            updatePasswordStrength(value);
            
            if (value) {
              const strength = getPasswordStrength(value);
              if (!strength.isValid) {
                showFieldError('register-password', '密碼需至少8位，包含大寫、小寫字母和數字');
              } else {
                hideFieldError('register-password');
              }
            }
          });
        }
        
        // Step 24: 啟用無限滾動
        setupInfiniteScroll();
        
        // 開始載入數據
        loadData();
      });
    </script>
  </body>
</html>